<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>QCP_group3.ErrorCorrection_test API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>QCP_group3.ErrorCorrection_test</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np

from Gate_File import Gate
from Q_Register_File import *
from Q_Register_File import Q_Register
from Tensor import TensorProduct
&#34;&#34;&#34;
class ErrorCorrection(object):

    def __init__(self, matrixType, initialRegister):

        self.register = initialRegister
        self.state = initialRegister.state
        
    def 

&#34;&#34;&#34;
base_states = []
base_states_matrices = []
for i in range(8):
    temp = np.zeros(8, dtype=complex)
    temp[i] = 1
    base_states.append(temp)
    base_states_matrices.append(DenseMatrix(np.outer(temp, temp)))
# print(base_states, base_states_matrices, sep=&#34;\n&#34;)


def trace_register(register):
    assert (isinstance(register.inputArray, np.ndarray) and
            len(register.inputArray) == 2**10), &#34;A register of 10 qubits is neccessary -&gt; register of 7 qubits + 3 qubit control&#34;

    out = np.zeros((2**7, 2**7), dtype=complex)

    for i in range(2**7):
        for j in range(2**7):

            old = register.inputArray[i*2**3:i*2**3+8, j*2**3:j*2**3+8]

            for t in range(3):
                new = np.zeros((2**(2-t), 2**(2-t)))
                for a in range(2**(2-t)):
                    for b in range(2**(2-t)):
                        new[a, b] = trace_single(old[a*2:a*2+2, b*2:b*2+2])
                old = new.copy()
            out[i, j] = old[0, 0]
    return DenseMatrix(out)


def trace_single(matrix):
    assert (isinstance(matrix, np.ndarray) and
            len(matrix) == 2), &#34;Need 2*2 matrix that is then traced to 0 or 1&#34;

    if matrix[0, 0] == 0 and matrix[1][1] == 0:
        return 0
    else:
        return matrix[0, 0] + matrix[1][1]
    
def normalize(vector):
    &#34;&#34;&#34;
    Normalizes a given vector
    &#34;&#34;&#34;
    norm = np.linalg.norm(vector)
    if norm == 0: 
       return vector
    return vector / norm

def runexampleQEC(bitindex, phaseindex):

    &#34;&#34;&#34;
    Runs quantum error correction on the CSS code construction of the Hamming [7,4,3] code. Takes the code for the |0&gt; state, applies the errors to the code
    and subsequently fixes them using parity checks. To do so, a 10 qubit state vector is used, where the first 7 qubits are the code and the last 3 qubits 
    are ancilla qubits. Parity checks are performed by using cNOT gate operations on the appropiate qubits and the ancilla. The index of the bit error is first
    calculated and the error is fixed. The ancilla qubits are then reset and the basis of the vector is changed with Hadamard gates. This maps phase errors into
    bit errors in the new basis. The same procedure is then performed to fix the error. Finally the state is returned to the initial state. The final corrected
    state is returned together with the indices for the bit and phase errors (qubit index = qubit number -1, qubit 1 has index 0).
    ------
    Input:

    bitindex - index for bit error placement
    phaseindex - index for phase error placement

    Output:

    FinalCleanStateVec = 7 qubit state that corresponds to the corrected Hamming[7,4,3] CSS code construction of |0&gt; (should always return this unless error correction
    has not worked correctly)
    errorpos1 - index for bit error (should be the same as bitindex)
    errorpos2 - index for phase error (should be the same as phaseindex)

    &#34;&#34;&#34;

    # State preparation (represents |0&gt; state)
    Register = Q_Register(10)
    indices = [0,840,816,120,720,408,480,680]
    Register.state[0] = 0
    for i in indices:
        Register.state[i] = (1/np.sqrt(8))

    HGate = Gate(&#34;Sparse&#34;, &#34;hadamard&#34;)
    XGate = Gate(&#34;Sparse&#34;, &#34;spinX&#34;)
    ZGate = Gate(&#34;Sparse&#34;, &#34;spinZ&#34;)
    CGate = Gate(&#34;Sparse&#34;,&#34;cNot&#34;)

    Register.apply_gate(XGate, [bitindex]) 
    Register.apply_gate(ZGate, [phaseindex]) 


    # Test for bit error first

    # First parity check
    paritylist1 = [0,2,4,6] # check qubits in positions 1,3,5,7
    for i in paritylist1:
        Register.apply_gate(CGate, [i,9])


    # Second parity check
    paritylist2 = [1,2,5,6] # check qubits in positions 2,3,6,7
    for i in paritylist2:
        Register.apply_gate(CGate, [i,8])

    # Third parity check
    paritylist3 = [3,4,5,6] # check qubits in positions 4,5,6,7
    for i in paritylist3:
        Register.apply_gate(CGate, [i,7])

    densitymat = DenseMatrix(np.outer(Register.state,Register.state))
    Id = DenseMatrix(np.eye(128))
    errorpos = 0

    # Get error position by multiplying with an orthogonal set of matrices corresponding to each basis state density matrix

    for i in range(8):
        TensorProd = TensorProduct([Id,base_states_matrices[i]]).denseTensorProduct()
        matrix = TensorProd.Multiply(densitymat)
        if not np.any(matrix.inputArray) == True:
            pass
        else:
            errorpos += i
            break

    if errorpos == 0:
        print(&#34;There is no bit error.&#34;)
    else:
        print(&#34;The bit error is in qubit &#34; + str(errorpos))

    # Fix error 
        
    Register.apply_gate(XGate, [errorpos-1])

    # Return ancilla qubits to |000&gt;

    if errorpos == 0:
        pass
    elif errorpos == 1:
        Register.apply_gate(XGate, [9])
    elif errorpos == 2:
        Register.apply_gate(XGate, [8])
    elif errorpos == 3:
        Register.apply_gate(XGate, [8,9])
    elif errorpos == 4:
        Register.apply_gate(XGate, [7])
    elif errorpos == 5:
        Register.apply_gate(XGate, [7,9])
    elif errorpos == 6:
        Register.apply_gate(XGate, [7,8])
    elif errorpos == 7:
        Register.apply_gate(XGate, [7,8,9])
    

    # Change basis of the system to change phase errors into bit flip errors

    Register.apply_gate(HGate, [0,1,2,3,4,5,6])

    # Run parity checks again

    # First parity check
    for i in paritylist1:
        Register.apply_gate(CGate, [i,9])

    # Second parity check
    for i in paritylist2:
        Register.apply_gate(CGate, [i,8])

    # Third parity check
    for i in paritylist3:
        Register.apply_gate(CGate, [i,7])

    # Return to initial basis

    Register.apply_gate(HGate, [0,1,2,3,4,5,6])

    densitymat2 = DenseMatrix(np.outer(Register.state,Register.state))
    errorpos2 = 0

    # Same procedure to find error position

    for i in range(8):
        TensorProd2 = TensorProduct([Id,base_states_matrices[i]]).denseTensorProduct()
        matrix2 = TensorProd2.Multiply(densitymat2)
        if not np.any(matrix2.inputArray) == True:
            pass
        else:
            errorpos2 += i
            break

    if errorpos2 == 0:
        print(&#34;There is no phase error.&#34;)
    else:
        print(&#34;The phase error is in qubit &#34; + str(errorpos2))

    # Fix error
        
    Register.apply_gate(ZGate, [errorpos2-1])

    # Find density matrix of final corrected state vector (note that ancilla qubits are still there)

    newdensitymat = DenseMatrix(np.outer(Register.state,Register.state))

    # Trace out ancilla qubits

    FinalCleanDensityMat = trace_register(TensorProduct([Id,base_states_matrices[errorpos2]]).denseTensorProduct().Multiply(newdensitymat))

    # Diagonal elements of traced out density matrix correspond to the superposed states

    FinalCleanStateVec = np.diagonal(FinalCleanDensityMat.inputArray).copy()

    # Clean up float value numpy errors (where sometimes 0 is written as a very small number) and normalize

    for i in range(len(FinalCleanStateVec)):
        if FinalCleanStateVec[i] &lt; 0.0001:
            FinalCleanStateVec[i] = 0
    FinalCleanStateVec = normalize(FinalCleanStateVec)

    # Print out corrected state (should be a superposition of 8 basis states in the 7 qubit computational basis)

    return(FinalCleanStateVec, errorpos-1, errorpos2-1)

&#39;&#39;&#39;
StateVec, bitindex, phaseindex = runexampleQEC(1,5)
print(StateVec)
print(bitindex)
print(phaseindex)
&#39;&#39;&#39;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="QCP_group3.ErrorCorrection_test.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>vector)</span>
</code></dt>
<dd>
<div class="desc"><p>Normalizes a given vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize(vector):
    &#34;&#34;&#34;
    Normalizes a given vector
    &#34;&#34;&#34;
    norm = np.linalg.norm(vector)
    if norm == 0: 
       return vector
    return vector / norm</code></pre>
</details>
</dd>
<dt id="QCP_group3.ErrorCorrection_test.runexampleQEC"><code class="name flex">
<span>def <span class="ident">runexampleQEC</span></span>(<span>bitindex, phaseindex)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs quantum error correction on the CSS code construction of the Hamming [7,4,3] code. Takes the code for the |0&gt; state, applies the errors to the code
and subsequently fixes them using parity checks. To do so, a 10 qubit state vector is used, where the first 7 qubits are the code and the last 3 qubits
are ancilla qubits. Parity checks are performed by using cNOT gate operations on the appropiate qubits and the ancilla. The index of the bit error is first
calculated and the error is fixed. The ancilla qubits are then reset and the basis of the vector is changed with Hadamard gates. This maps phase errors into
bit errors in the new basis. The same procedure is then performed to fix the error. Finally the state is returned to the initial state. The final corrected
state is returned together with the indices for the bit and phase errors (qubit index = qubit number -1, qubit 1 has index 0).</p>
<hr>
<p>Input:</p>
<p>bitindex - index for bit error placement
phaseindex - index for phase error placement</p>
<p>Output:</p>
<p>FinalCleanStateVec = 7 qubit state that corresponds to the corrected Hamming[7,4,3] CSS code construction of |0&gt; (should always return this unless error correction
has not worked correctly)
errorpos1 - index for bit error (should be the same as bitindex)
errorpos2 - index for phase error (should be the same as phaseindex)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runexampleQEC(bitindex, phaseindex):

    &#34;&#34;&#34;
    Runs quantum error correction on the CSS code construction of the Hamming [7,4,3] code. Takes the code for the |0&gt; state, applies the errors to the code
    and subsequently fixes them using parity checks. To do so, a 10 qubit state vector is used, where the first 7 qubits are the code and the last 3 qubits 
    are ancilla qubits. Parity checks are performed by using cNOT gate operations on the appropiate qubits and the ancilla. The index of the bit error is first
    calculated and the error is fixed. The ancilla qubits are then reset and the basis of the vector is changed with Hadamard gates. This maps phase errors into
    bit errors in the new basis. The same procedure is then performed to fix the error. Finally the state is returned to the initial state. The final corrected
    state is returned together with the indices for the bit and phase errors (qubit index = qubit number -1, qubit 1 has index 0).
    ------
    Input:

    bitindex - index for bit error placement
    phaseindex - index for phase error placement

    Output:

    FinalCleanStateVec = 7 qubit state that corresponds to the corrected Hamming[7,4,3] CSS code construction of |0&gt; (should always return this unless error correction
    has not worked correctly)
    errorpos1 - index for bit error (should be the same as bitindex)
    errorpos2 - index for phase error (should be the same as phaseindex)

    &#34;&#34;&#34;

    # State preparation (represents |0&gt; state)
    Register = Q_Register(10)
    indices = [0,840,816,120,720,408,480,680]
    Register.state[0] = 0
    for i in indices:
        Register.state[i] = (1/np.sqrt(8))

    HGate = Gate(&#34;Sparse&#34;, &#34;hadamard&#34;)
    XGate = Gate(&#34;Sparse&#34;, &#34;spinX&#34;)
    ZGate = Gate(&#34;Sparse&#34;, &#34;spinZ&#34;)
    CGate = Gate(&#34;Sparse&#34;,&#34;cNot&#34;)

    Register.apply_gate(XGate, [bitindex]) 
    Register.apply_gate(ZGate, [phaseindex]) 


    # Test for bit error first

    # First parity check
    paritylist1 = [0,2,4,6] # check qubits in positions 1,3,5,7
    for i in paritylist1:
        Register.apply_gate(CGate, [i,9])


    # Second parity check
    paritylist2 = [1,2,5,6] # check qubits in positions 2,3,6,7
    for i in paritylist2:
        Register.apply_gate(CGate, [i,8])

    # Third parity check
    paritylist3 = [3,4,5,6] # check qubits in positions 4,5,6,7
    for i in paritylist3:
        Register.apply_gate(CGate, [i,7])

    densitymat = DenseMatrix(np.outer(Register.state,Register.state))
    Id = DenseMatrix(np.eye(128))
    errorpos = 0

    # Get error position by multiplying with an orthogonal set of matrices corresponding to each basis state density matrix

    for i in range(8):
        TensorProd = TensorProduct([Id,base_states_matrices[i]]).denseTensorProduct()
        matrix = TensorProd.Multiply(densitymat)
        if not np.any(matrix.inputArray) == True:
            pass
        else:
            errorpos += i
            break

    if errorpos == 0:
        print(&#34;There is no bit error.&#34;)
    else:
        print(&#34;The bit error is in qubit &#34; + str(errorpos))

    # Fix error 
        
    Register.apply_gate(XGate, [errorpos-1])

    # Return ancilla qubits to |000&gt;

    if errorpos == 0:
        pass
    elif errorpos == 1:
        Register.apply_gate(XGate, [9])
    elif errorpos == 2:
        Register.apply_gate(XGate, [8])
    elif errorpos == 3:
        Register.apply_gate(XGate, [8,9])
    elif errorpos == 4:
        Register.apply_gate(XGate, [7])
    elif errorpos == 5:
        Register.apply_gate(XGate, [7,9])
    elif errorpos == 6:
        Register.apply_gate(XGate, [7,8])
    elif errorpos == 7:
        Register.apply_gate(XGate, [7,8,9])
    

    # Change basis of the system to change phase errors into bit flip errors

    Register.apply_gate(HGate, [0,1,2,3,4,5,6])

    # Run parity checks again

    # First parity check
    for i in paritylist1:
        Register.apply_gate(CGate, [i,9])

    # Second parity check
    for i in paritylist2:
        Register.apply_gate(CGate, [i,8])

    # Third parity check
    for i in paritylist3:
        Register.apply_gate(CGate, [i,7])

    # Return to initial basis

    Register.apply_gate(HGate, [0,1,2,3,4,5,6])

    densitymat2 = DenseMatrix(np.outer(Register.state,Register.state))
    errorpos2 = 0

    # Same procedure to find error position

    for i in range(8):
        TensorProd2 = TensorProduct([Id,base_states_matrices[i]]).denseTensorProduct()
        matrix2 = TensorProd2.Multiply(densitymat2)
        if not np.any(matrix2.inputArray) == True:
            pass
        else:
            errorpos2 += i
            break

    if errorpos2 == 0:
        print(&#34;There is no phase error.&#34;)
    else:
        print(&#34;The phase error is in qubit &#34; + str(errorpos2))

    # Fix error
        
    Register.apply_gate(ZGate, [errorpos2-1])

    # Find density matrix of final corrected state vector (note that ancilla qubits are still there)

    newdensitymat = DenseMatrix(np.outer(Register.state,Register.state))

    # Trace out ancilla qubits

    FinalCleanDensityMat = trace_register(TensorProduct([Id,base_states_matrices[errorpos2]]).denseTensorProduct().Multiply(newdensitymat))

    # Diagonal elements of traced out density matrix correspond to the superposed states

    FinalCleanStateVec = np.diagonal(FinalCleanDensityMat.inputArray).copy()

    # Clean up float value numpy errors (where sometimes 0 is written as a very small number) and normalize

    for i in range(len(FinalCleanStateVec)):
        if FinalCleanStateVec[i] &lt; 0.0001:
            FinalCleanStateVec[i] = 0
    FinalCleanStateVec = normalize(FinalCleanStateVec)

    # Print out corrected state (should be a superposition of 8 basis states in the 7 qubit computational basis)

    return(FinalCleanStateVec, errorpos-1, errorpos2-1)</code></pre>
</details>
</dd>
<dt id="QCP_group3.ErrorCorrection_test.trace_register"><code class="name flex">
<span>def <span class="ident">trace_register</span></span>(<span>register)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trace_register(register):
    assert (isinstance(register.inputArray, np.ndarray) and
            len(register.inputArray) == 2**10), &#34;A register of 10 qubits is neccessary -&gt; register of 7 qubits + 3 qubit control&#34;

    out = np.zeros((2**7, 2**7), dtype=complex)

    for i in range(2**7):
        for j in range(2**7):

            old = register.inputArray[i*2**3:i*2**3+8, j*2**3:j*2**3+8]

            for t in range(3):
                new = np.zeros((2**(2-t), 2**(2-t)))
                for a in range(2**(2-t)):
                    for b in range(2**(2-t)):
                        new[a, b] = trace_single(old[a*2:a*2+2, b*2:b*2+2])
                old = new.copy()
            out[i, j] = old[0, 0]
    return DenseMatrix(out)</code></pre>
</details>
</dd>
<dt id="QCP_group3.ErrorCorrection_test.trace_single"><code class="name flex">
<span>def <span class="ident">trace_single</span></span>(<span>matrix)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trace_single(matrix):
    assert (isinstance(matrix, np.ndarray) and
            len(matrix) == 2), &#34;Need 2*2 matrix that is then traced to 0 or 1&#34;

    if matrix[0, 0] == 0 and matrix[1][1] == 0:
        return 0
    else:
        return matrix[0, 0] + matrix[1][1]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="QCP_group3" href="index.html">QCP_group3</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="QCP_group3.ErrorCorrection_test.normalize" href="#QCP_group3.ErrorCorrection_test.normalize">normalize</a></code></li>
<li><code><a title="QCP_group3.ErrorCorrection_test.runexampleQEC" href="#QCP_group3.ErrorCorrection_test.runexampleQEC">runexampleQEC</a></code></li>
<li><code><a title="QCP_group3.ErrorCorrection_test.trace_register" href="#QCP_group3.ErrorCorrection_test.trace_register">trace_register</a></code></li>
<li><code><a title="QCP_group3.ErrorCorrection_test.trace_single" href="#QCP_group3.ErrorCorrection_test.trace_single">trace_single</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>